jvm内存模型
---JMM就是java解决多线程下内存共享的一个模型，与内存分区管理是不同的层面！


根据线程私有和线程共享来看：

线程私有：

---程序计数器：如果正在执行Java方法，则指向虚拟机字节码指令的地址，如果是native的，这个计算器的值为空。
---虚拟机栈：保存本地变量、操作数栈、动态链接、方法出口等信息。为执行java方法服务。
---本地方法栈：跟虚拟机栈作用相同，不过是为虚拟机执行native方法服务。

线程共享：

---堆：存放实例的地方。分为“新生代”和“老年代”，新生代又分为eden、from survivor、to survivor，默认比例是8:1:1。
---方法区：主要存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译以后的代码，其中运行时常量池也在方法区中。
 ---运行时常量池：用于存放编译期间生成的各种字面量和符号引用。

直接内存：

---它不是JVM运行时数据区的一部分，不受JVM的GC管理。其中Java NIO中的Buffer直接在堆外分配的就属于这个部分。


gc触发条件：eden满了minor gc，升到老年代的对象大于老年代剩余空间full gc，或者小于时被HandlePromotionFailure=false（默认为true）参数强制full gc。
gc回收的对象：从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。 从GC roor不可达。
gc回收算法：分代收集算法
---新生代采用复制清理、老年代采用标记-整理。

内存分配策略:
---对象优先在Eden分配
---大对象直接进入老年代
---长期存活的对象进入老年代。
   ---对象在eden出生，并且经过第一次minor Gc后仍然存活，而且可以被survivor容纳，将被移动到survivor空间，年龄设为1。每熬过一次minor gc，年龄就加1
。当达到默认的年龄（15岁），就会晋升老年代。该年龄阈值可以通过-XX:MaxTenuringThreshold设置。
---动态对象年龄判定
   ---如果在survivor空间中的相同年龄的所有对象大小的总和大于survivor的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到“15岁”


线程安全是编程中的术语，指某个函数 (计算机科学)、函数库在多线程环境中被调用时，能够正确地处理各个线程的局部变量，使程序功能正确完成, 所谓线程安全无非是要控制多个线程对某个资源的有序访问或修改。    


Object
---wait、notify、notifyAll 必须持有当前锁，否则抛出IllegalMonitorStateException

Thread
---yield(s) 表示让步。建议当前正在运行的线程做个让步，让出CPU时间给别的线程来运行。不靠谱
---join,等待线程结束。当一个线程t1在另一个线程t2上调用t1.join()方法的时候，线程t2将等待线程t1运行结束之后再开始运行。
---interrupt,中断线程。该中断状态设置为true，默认为false。如果线程(不是main线程)正在执行Thread.sleep、join 或者Object类的wait方法，将抛出

InterruptedException。

---Thread.interrupted() 测试当前线程是否已经中断。线程的中断状态 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一 次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。
